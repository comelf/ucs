package com.github.comelf;

import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.NoSuchElementException;

/**
 * ARC (Adaptive Replacement Cache) Algorithm Implementation
 *
 * ARC는 4개의 LRU 리스트를 사용:
 * - T1: 최근 한 번만 참조된 페이지 (recency)
 * - T2: 최근 두 번 이상 참조된 페이지 (frequency)
 * - B1: T1에서 제거된 페이지 히스토리 (ghost entries)
 * - B2: T2에서 제거된 페이지 히스토리 (ghost entries)
 *
 * 적응형 파라미터 p:
 * - T1의 목표 크기를 동적으로 조정
 * - B1 히트 시 p 증가 (recency 중시)
 * - B2 히트 시 p 감소 (frequency 중시)
 *
 * 2Q보다 다양한 접근 패턴에 적응적으로 대응
 *
 * @param <K> Key type
 * @param <V> Value type
 */
public class ARCCacheTable<K, V> {
    private static final int DEFAULT_CAPACITY = 101;
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    private CacheEntry<K, V>[] table;
    private int threshold;
    private float loadFactor;

    // 전체 캐시 크기
    private int maxSize;

    // 적응형 파라미터 p: T1의 목표 크기
    private int p;

    // T1: 최근 한 번 참조 (LRU)
    private final CacheEntry<K, V> t1Header;
    private int t1Size;

    // T2: 최근 두 번 이상 참조 (LRU)
    private final CacheEntry<K, V> t2Header;
    private int t2Size;

    // B1: T1에서 제거된 키 히스토리 (ghost entries)
    private final GhostEntry<K> b1Header;
    private int b1Size;

    // B2: T2에서 제거된 키 히스토리 (ghost entries)
    private final GhostEntry<K> b2Header;
    private int b2Size;

    private long defaultKeepTime = 0;

    // Statistics
    private int hitCount;
    private int missCount;
    private int putCount;
    private int evictionCount;
    private int adaptationCount;  // p 조정 횟수

    public ARCCacheTable() {
        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    public ARCCacheTable(int initCapacity, float loadFactor) {
        if (initCapacity < 0)
            throw new RuntimeException("Capacity Error: " + initCapacity);
        if (loadFactor <= 0)
            throw new RuntimeException("Load Count Error: " + loadFactor);
        if (initCapacity == 0)
            initCapacity = 1;

        this.loadFactor = loadFactor;
        this.table = new CacheEntry[initCapacity];
        this.threshold = (int) (initCapacity * loadFactor);

        // T1 초기화
        this.t1Header = new CacheEntry<>(null, null, 0, null, ListType.T1);
        this.t1Header.link_next = this.t1Header.link_prev = this.t1Header;

        // T2 초기화
        this.t2Header = new CacheEntry<>(null, null, 0, null, ListType.T2);
        this.t2Header.link_next = this.t2Header.link_prev = this.t2Header;

        // B1 초기화 (ghost entries)
        this.b1Header = new GhostEntry<>(null);
        this.b1Header.link_next = this.b1Header.link_prev = this.b1Header;

        // B2 초기화 (ghost entries)
        this.b2Header = new GhostEntry<>(null);
        this.b2Header.link_next = this.b2Header.link_prev = this.b2Header;
    }

    public ARCCacheTable<K, V> setMaxRow(int max) {
        if (max <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = max;
        this.p = 0;  // 초기에는 T1/T2 균등 분배
        return this;
    }

    public ARCCacheTable<K, V> setDefaultKeepTime(long time) {
        this.defaultKeepTime = time;
        return this;
    }

    public int size() {
        return t1Size + t2Size;
    }

    public synchronized V get(K key) {
        if (key == null)
            return null;

        CacheEntry<K, V> e = getEntry(key);
        if (e == null) {
            missCount++;
            return null;
        }

        if (e.isExpired()) {
            removeEntry(e);
            missCount++;
            return null;
        }

        hitCount++;
        // ARC 알고리즘: T1에 있으면 T2로 승격
        promoteToT2(e);

        return e.getValue();
    }

    public synchronized V getKeepAlive(K key, long keepAlive) {
        if (key == null)
            return null;

        CacheEntry<K, V> e = getEntry(key);
        if (e == null)
            return null;

        if (e.isExpired()) {
            removeEntry(e);
            return null;
        }

        e.keepAlive(keepAlive);
        promoteToT2(e);

        return e.getValue();
    }

    public synchronized V getKeepAlive(K key) {
        return getKeepAlive(key, defaultKeepTime);
    }

    private CacheEntry<K, V> getEntry(K key) {
        if (key == null)
            return null;

        CacheEntry<K, V>[] tab = table;
        int index = hash(key) % tab.length;

        for (CacheEntry<K, V> e = tab[index]; e != null; e = e.next) {
            if (CompareUtil.equals(e.key, key)) {
                return e;
            }
        }
        return null;
    }

    public synchronized V put(K key, V value) {
        return put(key, value, defaultKeepTime);
    }

    public synchronized V put(K key, V value, long keepTime) {
        if (key == null)
            return null;

        putCount++;

        // 이미 존재하는지 확인
        CacheEntry<K, V> existing = getEntry(key);
        if (existing != null) {
            V old = existing.value;
            existing.value = value;
            existing.keepAlive(keepTime);
            promoteToT2(existing);
            return old;
        }

        // B1 또는 B2에 있었는지 확인 (ghost entry)
        boolean inB1 = isInB1(key);
        boolean inB2 = isInB2(key);

        if (inB1) {
            // B1 히트: recency가 중요 -> p 증가
            adaptP(true);
            removeFromB1(key);

            // 공간 확보 후 T2로 직접 삽입
            if (size() >= maxSize) {
                replace(ListType.B1);
            }
            insertToT2(key, value, keepTime);
        } else if (inB2) {
            // B2 히트: frequency가 중요 -> p 감소
            adaptP(false);
            removeFromB2(key);

            // 공간 확보 후 T2로 직접 삽입
            if (size() >= maxSize) {
                replace(ListType.B2);
            }
            insertToT2(key, value, keepTime);
        } else {
            // 새로운 키: onMiss 로직 적용
            onMiss(key, value, keepTime);
        }

        return null;
    }

    /**
     * 적응형 파라미터 p 조정
     * @param b1Hit true면 B1 히트 (p 증가), false면 B2 히트 (p 감소)
     */
    private void adaptP(boolean b1Hit) {
        adaptationCount++;

        if (b1Hit) {
            // B1 히트: recency 패턴 -> T1 크기 증가
            int delta = (b2Size >= b1Size || b2Size == 0) ? 1 : (b1Size / b2Size);
            p = Math.min(p + delta, maxSize);
        } else {
            // B2 히트: frequency 패턴 -> T1 크기 감소
            int delta = (b1Size >= b2Size || b1Size == 0) ? 1 : (b2Size / b1Size);
            p = Math.max(p - delta, 0);
        }
    }

    /**
     * 캐시 교체 정책 (ARC의 핵심)
     * Caffeine ARC 알고리즘 구현 참고
     *
     * @param candidateType 삽입될 후보의 타입 (B2에서 온 것인지 확인용)
     */
    private void replace(ListType candidateType) {
        // if (|T1| ≥ 1) and ((x ∈ B2 and |T1| = p) or (|T1| > p))
        //   then move the LRU page of T1 to the top of B1 and remove it from the cache.
        // else move the LRU page in T2 to the top of B2 and remove it from the cache.

        if ((t1Size >= 1) && (((candidateType == ListType.B2) && (t1Size == p)) || (t1Size > p))) {
            // T1에서 제거하여 B1로 이동
            evictFromT1ToB1();
        } else {
            // T2에서 제거하여 B2로 이동
            evictFromT2ToB2();
        }
    }

    /**
     * 캐시 미스 처리 (새로운 키)
     * Caffeine ARC onMiss 알고리즘 구현
     *
     * x ∈ L1 ∪ L2 (a miss in DBL(2c) and ARC(c)):
     * case (i) |L1| >= c:
     *   If |T1| < c then delete the LRU page of B1 and REPLACE(p).
     *   else delete LRU page of T1 and remove it from the cache.
     * case (ii) |L1| < c and |L1| + |L2| >= c:
     *   if |L1| + |L2| = 2c then delete the LRU page of B2.
     *   REPLACE(p).
     * Put x at the top of T1 and place it in the cache.
     */
    private void onMiss(K key, V value, long keepTime) {
        int l1Size = t1Size + b1Size;  // L1 = T1 ∪ B1
        int l2Size = t2Size + b2Size;  // L2 = T2 ∪ B2

        // case (i) |L1| >= c (changed from == to handle growing L1)
        if (l1Size >= maxSize) {
            if (t1Size < maxSize) {
                // T1이 여유가 있으면 B1에서 제거 후 replace
                removeLRUFromB1();
                replace(ListType.B1);
            } else {
                // T1이 꽉 찼으면 T1에서 제거 (B1로 이동됨)
                evictFromT1ToB1();
            }
        }
        // case (ii) |L1| < c and |L1| + |L2| >= c
        else if (l1Size < maxSize && (l1Size + l2Size) >= maxSize) {
            if ((l1Size + l2Size) >= (2 * maxSize)) {
                // 전체가 꽉 찼으면 B2에서 제거
                removeLRUFromB2();
            }
            replace(ListType.B1);
        }

        // Put x at the top of T1 and place it in the cache
        insertToT1(key, value, keepTime);
    }

    private void insertToT1(K key, V value, long keepTime) {
        // onMiss에서 이미 공간 관리를 수행했으므로 여기서는 삽입만 수행
        if (size() >= threshold) {
            rehash();
        }

        CacheEntry<K, V>[] tab = table;
        int index = hash(key) % tab.length;

        CacheEntry<K, V> e = new CacheEntry<>(key, value, keepTime, tab[index], ListType.T1);
        tab[index] = e;

        // T1 MRU 위치에 추가
        chain(t1Header.link_prev, t1Header, e);
        t1Size++;
    }

    private void insertToT2(K key, V value, long keepTime) {
        if (size() >= threshold) {
            rehash();
        }

        CacheEntry<K, V>[] tab = table;
        int index = hash(key) % tab.length;

        CacheEntry<K, V> e = new CacheEntry<>(key, value, keepTime, tab[index], ListType.T2);
        tab[index] = e;

        // T2 MRU 위치에 추가
        chain(t2Header.link_prev, t2Header, e);
        t2Size++;
    }

    private void promoteToT2(CacheEntry<K, V> e) {
        if (e.listType == ListType.T2) {
            // 이미 T2에 있으면 MRU로 이동
            if (t2Header.link_prev != e) {
                unchain(e);
                chain(t2Header.link_prev, t2Header, e);
            }
        } else if (e.listType == ListType.T1) {
            // T1에서 T2로 승격
            unchain(e);
            t1Size--;
            e.listType = ListType.T2;

            chain(t2Header.link_prev, t2Header, e);
            t2Size++;
        }
    }

    /**
     * T1에서 LRU 제거하여 B1로 이동 (캐시에서 완전 제거)
     */
    private void evictFromT1ToB1() {
        if (t1Size == 0)
            return;

        CacheEntry<K, V> victim = t1Header.link_next;
        if (victim == t1Header)
            return;

        K key = victim.key;
        V value = victim.value;

        removeFromHashTable(key);
        unchain(victim);
        t1Size--;
        evictionCount++;

        // 콜백 호출
        entryRemoved(true, key, value, null);

        // B1에 ghost entry 추가
        addToB1(key);
    }

    /**
     * T2에서 LRU 제거하여 B2로 이동 (캐시에서 완전 제거)
     */
    private void evictFromT2ToB2() {
        if (t2Size == 0)
            return;

        CacheEntry<K, V> victim = t2Header.link_next;
        if (victim == t2Header)
            return;

        K key = victim.key;
        V value = victim.value;

        removeFromHashTable(key);
        unchain(victim);
        t2Size--;
        evictionCount++;

        // 콜백 호출
        entryRemoved(true, key, value, null);

        // B2에 ghost entry 추가
        addToB2(key);
    }

    private void addToB1(K key) {
        GhostEntry<K> ghost = new GhostEntry<>(key);
        chainGhost(b1Header.link_prev, b1Header, ghost);
        b1Size++;
    }

    private void addToB2(K key) {
        GhostEntry<K> ghost = new GhostEntry<>(key);
        chainGhost(b2Header.link_prev, b2Header, ghost);
        b2Size++;
    }

    private boolean isInB1(K key) {
        GhostEntry<K> current = b1Header.link_next;
        while (current != b1Header) {
            if (CompareUtil.equals(current.key, key)) {
                return true;
            }
            current = current.link_next;
        }
        return false;
    }

    private boolean isInB2(K key) {
        GhostEntry<K> current = b2Header.link_next;
        while (current != b2Header) {
            if (CompareUtil.equals(current.key, key)) {
                return true;
            }
            current = current.link_next;
        }
        return false;
    }

    private void removeFromB1(K key) {
        GhostEntry<K> current = b1Header.link_next;
        while (current != b1Header) {
            if (CompareUtil.equals(current.key, key)) {
                unchainGhost(current);
                b1Size--;
                return;
            }
            current = current.link_next;
        }
    }

    private void removeFromB2(K key) {
        GhostEntry<K> current = b2Header.link_next;
        while (current != b2Header) {
            if (CompareUtil.equals(current.key, key)) {
                unchainGhost(current);
                b2Size--;
                return;
            }
            current = current.link_next;
        }
    }

    private void removeLRUFromB1() {
        if (b1Size == 0)
            return;

        GhostEntry<K> oldest = b1Header.link_next;
        if (oldest != b1Header) {
            unchainGhost(oldest);
            b1Size--;
        }
    }

    private void removeLRUFromB2() {
        if (b2Size == 0)
            return;

        GhostEntry<K> oldest = b2Header.link_next;
        if (oldest != b2Header) {
            unchainGhost(oldest);
            b2Size--;
        }
    }

    private void removeFromHashTable(K key) {
        if (key == null)
            return;

        CacheEntry<K, V>[] tab = table;
        int index = hash(key) % tab.length;

        for (CacheEntry<K, V> e = tab[index], prev = null; e != null; prev = e, e = e.next) {
            if (CompareUtil.equals(e.key, key)) {
                if (prev != null) {
                    prev.next = e.next;
                } else {
                    tab[index] = e.next;
                }
                return;
            }
        }
    }

    private void removeEntry(CacheEntry<K, V> e) {
        removeFromHashTable(e.key);
        unchain(e);

        if (e.listType == ListType.T1) {
            t1Size--;
        } else if (e.listType == ListType.T2) {
            t2Size--;
        }
    }

    public synchronized V remove(K key) {
        if (key == null)
            return null;

        CacheEntry<K, V> e = getEntry(key);
        if (e == null)
            return null;

        V value = e.value;
        removeEntry(e);

        // Ghost 리스트에서도 제거
        removeFromB1(key);
        removeFromB2(key);

        return value;
    }

    public synchronized void clear() {
        CacheEntry<K, V>[] tab = table;
        for (int index = tab.length; --index >= 0;)
            tab[index] = null;

        t1Header.link_next = t1Header.link_prev = t1Header;
        t2Header.link_next = t2Header.link_prev = t2Header;
        b1Header.link_next = b1Header.link_prev = b1Header;
        b2Header.link_next = b2Header.link_prev = b2Header;

        t1Size = 0;
        t2Size = 0;
        b1Size = 0;
        b2Size = 0;
        p = 0;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public synchronized boolean containsKey(K key) {
        return getEntry(key) != null;
    }

    public synchronized Enumeration<K> keys() {
        return new Enumer<K>(TYPE.KEYS);
    }

    public synchronized Enumeration<V> values() {
        return new Enumer<V>(TYPE.VALUES);
    }

    public synchronized Enumeration<CacheEntry<K, V>> entries() {
        return new Enumer<CacheEntry<K, V>>(TYPE.ENTRIES);
    }

    private int hash(Object key) {
        return (int) (key.hashCode()) & Integer.MAX_VALUE;
    }

    protected void rehash() {
        int oldCapacity = table.length;
        CacheEntry<K, V>[] oldMap = table;
        int newCapacity = oldCapacity * 2 + 1;
        CacheEntry<K, V>[] newMap = new CacheEntry[newCapacity];

        threshold = (int) (newCapacity * loadFactor);
        table = newMap;

        for (int i = oldCapacity; i-- > 0;) {
            for (CacheEntry<K, V> old = oldMap[i]; old != null;) {
                CacheEntry<K, V> e = old;
                old = old.next;
                K key = e.key;
                int index = hash(key) % newCapacity;
                e.next = newMap[index];
                newMap[index] = e;
            }
        }
    }

    public String getStats() {
        return String.format("ARCCache[total=%d/%d, T1=%d, T2=%d, B1=%d, B2=%d, p=%d]",
                size(), maxSize, t1Size, t2Size, b1Size, b2Size, p);
    }

    private void chain(CacheEntry<K, V> link_prev, CacheEntry<K, V> link_next, CacheEntry<K, V> e) {
        e.link_prev = link_prev;
        e.link_next = link_next;
        link_prev.link_next = e;
        link_next.link_prev = e;
    }

    private void unchain(CacheEntry<K, V> e) {
        e.link_prev.link_next = e.link_next;
        e.link_next.link_prev = e.link_prev;
        e.link_prev = null;
        e.link_next = null;
    }

    private void chainGhost(GhostEntry<K> link_prev, GhostEntry<K> link_next, GhostEntry<K> e) {
        e.link_prev = link_prev;
        e.link_next = link_next;
        link_prev.link_next = e;
        link_next.link_prev = e;
    }

    private void unchainGhost(GhostEntry<K> e) {
        e.link_prev.link_next = e.link_next;
        e.link_next.link_prev = e.link_prev;
        e.link_prev = null;
        e.link_next = null;
    }

    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
        // 기본 구현은 비어있음. 서브클래스에서 override
    }

    public synchronized void resize(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }

        this.maxSize = maxSize;
        this.p = 0;  // 재설정

        Map<K, V> snapshot = snapshot();
        clear();

        for (Map.Entry<K, V> entry : snapshot.entrySet()) {
            put(entry.getKey(), entry.getValue());
        }
    }

    public synchronized Map<K, V> snapshot() {
        Map<K, V> result = new HashMap<K, V>();

        // T1 항목 수집
        CacheEntry<K, V> current = t1Header.link_next;
        while (current != t1Header) {
            result.put(current.key, current.value);
            current = current.link_next;
        }

        // T2 항목 수집
        current = t2Header.link_next;
        while (current != t2Header) {
            result.put(current.key, current.value);
            current = current.link_next;
        }

        return result;
    }

    public synchronized int hitCount() {
        return hitCount;
    }

    public synchronized int missCount() {
        return missCount;
    }

    public synchronized int putCount() {
        return putCount;
    }

    public synchronized int evictionCount() {
        return evictionCount;
    }

    public synchronized int adaptationCount() {
        return adaptationCount;
    }

    public synchronized int getP() {
        return p;
    }

    public synchronized float hitRate() {
        int accesses = hitCount + missCount;
        return accesses != 0 ? (float) hitCount / accesses : 0.0f;
    }

    public synchronized int maxSize() {
        return maxSize;
    }

    @Override
    public synchronized String toString() {
        int accesses = hitCount + missCount;
        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
        return String.format("ARCCache[size=%d/%d, hits=%d, misses=%d, hitRate=%d%%, " +
                        "T1=%d, T2=%d, B1=%d, B2=%d, p=%d, adaptations=%d, puts=%d, evictions=%d]",
                size(), maxSize, hitCount, missCount, hitPercent,
                t1Size, t2Size, b1Size, b2Size, p, adaptationCount,
                putCount, evictionCount);
    }

    private enum ListType {
        T1, T2, B1, B2
    }

    public static class CacheEntry<K, V> {
        private K key;
        private V value;
        private long timeOfExpiration;
        private long keepTime = 0;
        private ListType listType;

        CacheEntry<K, V> next;
        CacheEntry<K, V> link_next, link_prev;

        protected CacheEntry(K key, V value, long keepTime, CacheEntry<K, V> next, ListType listType) {
            this.key = key;
            this.value = value;
            this.listType = listType;
            this.keepAlive(keepTime);
            this.next = next;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        public boolean isExpired() {
            if (timeOfExpiration > 0) {
                return timeOfExpiration < DateUtil.currentTime();
            }
            return false;
        }

        public void keepAlive(long keepTime) {
            if (keepTime > 0) {
                this.keepTime = keepTime;
                this.timeOfExpiration = DateUtil.currentTime() + keepTime;
            } else {
                this.keepTime = 0;
                this.timeOfExpiration = 0;
            }
        }

        public String toString() {
            return key + "=" + value + "[" + listType + "]";
        }
    }

    private static class GhostEntry<K> {
        private K key;
        GhostEntry<K> link_next, link_prev;

        protected GhostEntry(K key) {
            this.key = key;
        }
    }

    private enum TYPE {
        KEYS, VALUES, ENTRIES
    }

    private class Enumer<T> implements Enumeration<T> {
        TYPE type;
        CacheEntry<K, V> t1Entry;
        CacheEntry<K, V> t2Entry;
        boolean inT1 = true;

        Enumer(TYPE type) {
            this.type = type;
            this.t1Entry = ARCCacheTable.this.t1Header.link_next;
            this.t2Entry = ARCCacheTable.this.t2Header.link_next;
        }

        public boolean hasMoreElements() {
            if (inT1 && t1Entry != t1Header) {
                return true;
            }
            inT1 = false;
            return t2Entry != t2Header && t2Entry != null;
        }

        public T nextElement() {
            if (!hasMoreElements()) {
                throw new NoSuchElementException("no more next");
            }

            CacheEntry<K, V> e;
            if (inT1) {
                e = t1Entry;
                t1Entry = e.link_next;
            } else {
                e = t2Entry;
                t2Entry = e.link_next;
            }

            switch (type) {
                case KEYS:
                    return (T) e.key;
                case VALUES:
                    return (T) e.value;
                default:
                    return (T) e;
            }
        }
    }
}
