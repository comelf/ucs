package com.github.comelf;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("ARCCacheTable 테스트")
class ARCCacheTableTest {

    public static class ARCCacheTableWithStats<K, V> extends ARCCacheTable<K, V> {
    
        // Statistics
        private int hitCount;
        private int missCount;
        private int putCount;
        private int evictionCount;
        private int adaptationCount;  // Number of p adjustments
    
        public ARCCacheTableWithStats() {
            super();
        }
    
        public ARCCacheTableWithStats(int initCapacity, float loadFactor) {
            super(initCapacity, loadFactor);
        }
    
        @Override
        public ARCCacheTableWithStats<K, V> setMaxRow(int max) {
            super.setMaxRow(max);
            return this;
        }
    
        @Override
        public ARCCacheTableWithStats<K, V> setDefaultKeepTime(long time) {
            super.setDefaultKeepTime(time);
            return this;
        }
    
        @Override
        public synchronized V get(K key) {
            V result = super.get(key);
            if (result == null) {
                missCount++;
            } else {
                hitCount++;
            }
            return result;
        }
    
        @Override
        public synchronized V put(K key, V value, long keepTime) {
            putCount++;
            return super.put(key, value, keepTime);
        }
    
        @Override
        protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
            super.entryRemoved(evicted, key, oldValue, newValue);
            if (evicted) {
                evictionCount++;
            }
        }
    
        @Override
        protected void onAdaptation() {
            adaptationCount++;
        }
    
        @Override
        protected void onEviction() {
            evictionCount++;
        }
    
        @Override
        public synchronized void clear() {
            super.clear();
            hitCount = 0;
            missCount = 0;
            putCount = 0;
            evictionCount = 0;
            adaptationCount = 0;
        }
    
        // Statistics accessor methods
    
        public synchronized int hitCount() {
            return hitCount;
        }
    
        public synchronized int missCount() {
            return missCount;
        }
    
        public synchronized int putCount() {
            return putCount;
        }
    
        public synchronized int evictionCount() {
            return evictionCount;
        }
    
        public synchronized int adaptationCount() {
            return adaptationCount;
        }
    
        public synchronized float hitRate() {
            int accesses = hitCount + missCount;
            return accesses != 0 ? (float) hitCount / accesses : 0.0f;
        }
    
        @Override
        public synchronized String toString() {
            int accesses = hitCount + missCount;
            int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
            return String.format("ARCCache[size=%d/%d, hits=%d, misses=%d, hitRate=%d%%, " +
                            "T1=%d, T2=%d, B1=%d, B2=%d, p=%d, adaptations=%d, puts=%d, evictions=%d]",
                    size(), maxSize(), hitCount, missCount, hitPercent,
                    getT1Size(), getT2Size(), getB1Size(), getB2Size(), getP(), adaptationCount,
                    putCount, evictionCount);
        }
    
        public String getStats() {
            return String.format("ARCCache[total=%d/%d, T1=%d, T2=%d, B1=%d, B2=%d, p=%d]",
                    size(), maxSize(), getT1Size(), getT2Size(), getB1Size(), getB2Size(), getP());
        }
    }

    private ARCCacheTableWithStats<Integer, String> cache;

    @BeforeEach
    void setUp() {
        cache = new ARCCacheTableWithStats<Integer, String>().setMaxRow(10);
    }

    @Test
    @DisplayName("기본 put/get 동작 확인")
    void testBasicPutGet() {
        cache.put(1, "one");
        cache.put(2, "two");
        cache.put(3, "three");

        assertThat(cache.get(1)).isEqualTo("one");
        assertThat(cache.get(2)).isEqualTo("two");
        assertThat(cache.get(3)).isEqualTo("three");
        assertThat(cache.size()).isEqualTo(3);
    }

    @Test
    @DisplayName("존재하지 않는 키 조회 시 null 반환")
    void testGetNonExistentKey() {
        assertThat(cache.get(999)).isNull();
        assertThat(cache.missCount()).isGreaterThan(0);
    }

    @Test
    @DisplayName("캐시가 꽉 찬 경우 eviction 발생")
    void testEvictionWhenFull() {
        // maxSize=10이므로 10개 초과 시 eviction
        for (int i = 1; i <= 15; i++) {
            cache.put(i, "value" + i);
        }

        assertThat(cache.size()).isEqualTo(10);
        assertThat(cache.evictionCount()).isGreaterThan(0);
    }

    @Test
    @DisplayName("T1에서 T2로 승격 - 두 번 액세스 시")
    void testPromotionFromT1ToT2() {
        cache.put(1, "one");

        // 첫 번째 get: T1에 유지
        String first = cache.get(1);
        assertThat(first).isEqualTo("one");

        // 두 번째 get: T2로 승격됨
        String second = cache.get(1);
        assertThat(second).isEqualTo("one");

        // 통계 확인
        assertThat(cache.hitCount()).isEqualTo(2);
        assertThat(cache.size()).isEqualTo(1);
    }

    @Test
    @DisplayName("Sequential scan 패턴 - LRU의 약점 테스트")
    void testSequentialScanPattern() {
        // max=10, 1~20을 반복 접근
        ARCCacheTableWithStats<Integer, String> smallCache = new ARCCacheTableWithStats<Integer, String>().setMaxRow(10);

        // 첫 번째 pass
        for (int i = 1; i <= 20; i++) {
            smallCache.put(i, "value" + i);
        }

        int hitCountAfterFirstPass = smallCache.hitCount();

        // 두 번째 pass - 일부는 ghost entry에서 재활용될 수 있음
        for (int i = 1; i <= 20; i++) {
            smallCache.put(i, "value" + i);
        }

        int hitCountAfterSecondPass = smallCache.hitCount();

        // ARC는 ghost entry를 통해 적응하므로 일부 개선 가능
        assertThat(smallCache.size()).isEqualTo(10);
        assertThat(smallCache.adaptationCount()).isGreaterThan(0);

        System.out.println("Sequential scan test:");
        System.out.println("  " + smallCache.toString());
    }

    @Test
    @DisplayName("적응형 파라미터 p 조정 - B1 히트 시 증가")
    void testAdaptiveParameterPIncreaseOnB1Hit() {
        // T1을 채우고 evict하여 B1에 ghost entry 생성
        for (int i = 1; i <= 12; i++) {
            cache.put(i, "value" + i);
        }

        int initialP = cache.getP();

        // B1에 있던 키를 다시 put (B1 히트)
        cache.put(1, "value1_new");

        // B1 히트 시 p가 증가해야 함 (recency 중시)
        assertThat(cache.adaptationCount()).isGreaterThan(0);

        System.out.println("B1 hit test:");
        System.out.println("  Initial p: " + initialP);
        System.out.println("  After B1 hit: " + cache.getP());
        System.out.println("  " + cache.getStats());
    }

    @Test
    @DisplayName("Hit rate 계산 확인")
    void testHitRateCalculation() {
        for (int i = 1; i <= 5; i++) {
            cache.put(i, "value" + i);
        }

        // 5번 hit
        for (int i = 1; i <= 5; i++) {
            cache.get(i);
        }

        // 5번 miss
        for (int i = 6; i <= 10; i++) {
            cache.get(i);
        }

        assertThat(cache.hitCount()).isEqualTo(5);
        assertThat(cache.missCount()).isEqualTo(5);
        assertThat(cache.hitRate()).isEqualTo(0.5f);

        System.out.println("Hit rate test: " + cache.toString());
    }

    @Test
    @DisplayName("containsKey 메소드 확인")
    void testContainsKey() {
        cache.put(1, "one");

        assertThat(cache.containsKey(1)).isTrue();
        assertThat(cache.containsKey(2)).isFalse();
    }

    @Test
    @DisplayName("remove 메소드 확인")
    void testRemove() {
        cache.put(1, "one");
        cache.put(2, "two");

        String removed = cache.remove(1);

        assertThat(removed).isEqualTo("one");
        assertThat(cache.get(1)).isNull();
        assertThat(cache.size()).isEqualTo(1);
    }

    @Test
    @DisplayName("clear 메소드 확인")
    void testClear() {
        for (int i = 1; i <= 5; i++) {
            cache.put(i, "value" + i);
        }

        cache.clear();

        assertThat(cache.size()).isEqualTo(0);
        assertThat(cache.isEmpty()).isTrue();
        assertThat(cache.getP()).isEqualTo(0);
    }

    @Test
    @DisplayName("Resize 메소드 확인")
    void testResize() {
        for (int i = 1; i <= 10; i++) {
            cache.put(i, "value" + i);
        }

        assertThat(cache.size()).isEqualTo(10);

        // 크기를 5로 축소
        cache.resize(5);

        assertThat(cache.maxSize()).isEqualTo(5);
        assertThat(cache.size()).isLessThanOrEqualTo(5);
        assertThat(cache.getP()).isEqualTo(0); // p가 리셋됨
    }

    @Test
    @DisplayName("Time expiration 확인")
    void testTimeExpiration() throws InterruptedException {
        // 100ms 후 만료
        cache.put(1, "one", 100);

        assertThat(cache.get(1)).isEqualTo("one");

        // 150ms 대기
        Thread.sleep(150);

        // 만료되어 null 반환
        assertThat(cache.get(1)).isNull();
        assertThat(cache.size()).isEqualTo(0);
    }

    @Test
    @DisplayName("getKeepAlive 메소드로 TTL 갱신")
    void testGetKeepAlive() throws InterruptedException {
        cache.setDefaultKeepTime(200);
        cache.put(1, "one");

        // 100ms 대기
        Thread.sleep(100);

        // keepAlive로 TTL 갱신
        assertThat(cache.getKeepAlive(1, 200)).isEqualTo("one");

        // 추가 100ms 대기 (원래라면 만료되었을 시점)
        Thread.sleep(100);

        // 여전히 유효해야 함
        assertThat(cache.get(1)).isEqualTo("one");
    }

    @Test
    @DisplayName("Null 키 처리")
    void testNullKeyHandling() {
        assertThat(cache.put(null, "value")).isNull();
        assertThat(cache.get(null)).isNull();
        assertThat(cache.remove(null)).isNull();
    }

    @Test
    @DisplayName("값 업데이트 시 기존 값 반환")
    void testUpdateReturnsOldValue() {
        cache.put(1, "old");
        String oldValue = cache.put(1, "new");

        assertThat(oldValue).isEqualTo("old");
        assertThat(cache.get(1)).isEqualTo("new");
    }

    @Test
    @DisplayName("Snapshot 메소드 확인")
    void testSnapshot() {
        for (int i = 1; i <= 5; i++) {
            cache.put(i, "value" + i);
        }

        java.util.Map<Integer, String> snapshot = cache.snapshot();

        assertThat(snapshot.size()).isEqualTo(5);
        assertThat(snapshot.get(1)).isEqualTo("value1");
        assertThat(snapshot.get(5)).isEqualTo("value5");
    }

    @Test
    @DisplayName("혼합 워크로드 - 반복적 액세스와 새로운 항목")
    void testMixedWorkload() {
        // Hot data: 1-5 (자주 액세스)
        for (int round = 0; round < 3; round++) {
            // Hot data 액세스
            for (int i = 1; i <= 5; i++) {
                cache.put(i, "hot" + i + "_r" + round);
            }
        }

        // Cold data: 6-20 (한 번만 액세스)
        for (int i = 6; i <= 20; i++) {
            cache.put(i, "cold" + i + "_r" + 0);
        }

        // Hot data는 캐시에 남아있을 가능성 높음
        int hotHits = 0;
        for (int i = 1; i <= 5; i++) {
            if (cache.get(i) != null) {
                hotHits++;
            }
        }

        System.out.println("Mixed workload test:");
        System.out.println("  Hot data hits: " + hotHits + "/5");
        System.out.println("  " + cache.toString());

        // ARC가 hot data를 더 잘 유지해야 함
        assertThat(hotHits).isGreaterThan(0);
    }

    @Test
    @DisplayName("통계 초기값 확인")
    void testInitialStatistics() {
        ARCCacheTableWithStats<String, String> newCache = new ARCCacheTableWithStats<String, String>().setMaxRow(10);

        assertThat(newCache.size()).isEqualTo(0);
        assertThat(newCache.hitCount()).isEqualTo(0);
        assertThat(newCache.missCount()).isEqualTo(0);
        assertThat(newCache.putCount()).isEqualTo(0);
        assertThat(newCache.evictionCount()).isEqualTo(0);
        assertThat(newCache.adaptationCount()).isEqualTo(0);
        assertThat(newCache.getP()).isEqualTo(0);
        assertThat(newCache.hitRate()).isEqualTo(0.0f);
    }

    @Test
    @DisplayName("Enumeration 테스트")
    void testEnumeration() {
        for (int i = 1; i <= 5; i++) {
            cache.put(i, "value" + i);
        }

        // Keys enumeration
        java.util.Enumeration<Integer> keys = cache.keys();
        int keyCount = 0;
        while (keys.hasMoreElements()) {
            keys.nextElement();
            keyCount++;
        }
        assertThat(keyCount).isEqualTo(5);

        // Values enumeration
        java.util.Enumeration<String> values = cache.values();
        int valueCount = 0;
        while (values.hasMoreElements()) {
            values.nextElement();
            valueCount++;
        }
        assertThat(valueCount).isEqualTo(5);
    }

    // ====== Production-Level Tests ======

    @Test
    @DisplayName("Ghost entry 크기 제한 - 메모리 누수 방지")
    void testGhostEntrySizeBounds() {
        ARCCacheTable<Integer, String> cache = new ARCCacheTable<Integer, String>().setMaxRow(100);

        // Insert 1000 items to force many evictions and ghost entries
        for (int i = 0; i < 1000; i++) {
            cache.put(i, "value" + i);
        }

        // Verify that total size (T1 + T2 + B1 + B2) doesn't exceed 2 * maxSize
        int totalSize = cache.size(); // T1 + T2 should be <= 100
        assertThat(totalSize).isLessThanOrEqualTo(100);

        System.out.println("Ghost entry bounds test: " + cache.getStats());
        System.out.println("  Cache size: " + cache.size());
        System.out.println("  Max size: " + cache.maxSize());
    }

    @Test
    @DisplayName("동시성 테스트 - 멀티스레드 환경")
    void testConcurrency() throws InterruptedException {
        ARCCacheTable<Integer, String> cache = new ARCCacheTable<Integer, String>().setMaxRow(1000);

        int numThreads = 10;
        int operationsPerThread = 1000;
        java.util.concurrent.CountDownLatch startLatch = new java.util.concurrent.CountDownLatch(1);
        java.util.concurrent.CountDownLatch doneLatch = new java.util.concurrent.CountDownLatch(numThreads);
        java.util.concurrent.atomic.AtomicInteger errorCount = new java.util.concurrent.atomic.AtomicInteger(0);

        // Create threads that perform concurrent put/get operations
        for (int t = 0; t < numThreads; t++) {
            final int threadId = t;
            new Thread(() -> {
                try {
                    startLatch.await(); // Wait for all threads to be ready

                    for (int i = 0; i < operationsPerThread; i++) {
                        int key = (threadId * operationsPerThread + i) % 500; // Some overlap
                        cache.put(key, "thread-" + threadId + "-value-" + i);

                        if (i % 3 == 0) {
                            cache.get(key);
                        }
                    }
                } catch (Exception e) {
                    errorCount.incrementAndGet();
                    e.printStackTrace();
                } finally {
                    doneLatch.countDown();
                }
            }).start();
        }

        startLatch.countDown(); // Start all threads
        doneLatch.await(); // Wait for all threads to finish

        assertThat(errorCount.get()).isEqualTo(0);
        assertThat(cache.size()).isLessThanOrEqualTo(1000);

        System.out.println("Concurrency test: " + cache.toString());
    }

    @Test
    @DisplayName("대용량 데이터 처리 테스트")
    void testLargeDataVolume() {
        ARCCacheTable<Integer, String> cache = new ARCCacheTable<Integer, String>().setMaxRow(10000);

        long startTime = System.currentTimeMillis();

        // Insert 100,000 items
        for (int i = 0; i < 100000; i++) {
            cache.put(i, "value" + i);
        }

        long insertTime = System.currentTimeMillis() - startTime;

        // Access hot data (recent 20%)
        startTime = System.currentTimeMillis();
        int hits = 0;
        for (int i = 80000; i < 100000; i++) {
            if (cache.get(i) != null) {
                hits++;
            }
        }
        long accessTime = System.currentTimeMillis() - startTime;

        System.out.println("Large data volume test:");
        System.out.println("  Insert time: " + insertTime + "ms for 100,000 items");
        System.out.println("  Access time: " + accessTime + "ms for 20,000 items");
        System.out.println("  Hot data hits: " + hits + "/20000");
        System.out.println("  " + cache.toString());

        assertThat(cache.size()).isEqualTo(10000);
        assertThat(hits).isGreaterThan(0); // Some hot data should be in cache
    }

    @Test
    @DisplayName("Stress test - 장시간 반복 실행")
    void testStress() {
        ARCCacheTableWithStats<Integer, String> cache = new ARCCacheTableWithStats<Integer, String>().setMaxRow(500);

        // Simulate 10,000 rounds of operations
        for (int round = 0; round < 10000; round++) {
            // Mix of operations
            for (int i = 0; i < 10; i++) {
                int key = (round * 10 + i) % 2000; // Cycling through keys
                cache.put(key, "round-" + round + "-value-" + i);

                if (i % 2 == 0) {
                    cache.get(key);
                }
            }
        }

        System.out.println("Stress test completed: " + cache.toString());

        assertThat(cache.size()).isLessThanOrEqualTo(500);
        assertThat(cache.putCount()).isEqualTo(100000);
        assertThat(cache.hitCount()).isGreaterThan(0);
    }

    @Test
    @DisplayName("Performance benchmark - Hit rate 측정")
    void testPerformanceBenchmark() {
        ARCCacheTable<Integer, String> cache = new ARCCacheTable<Integer, String>().setMaxRow(500);

        // Scenario: 80-20 rule (80% accesses to 20% of hot data)
        // Hot data: 0-99 (100 items)
        // Cold data: 100-999 (900 items)
        // Cache size: 500

        // Initial load - put all data once
        for (int i = 0; i < 1000; i++) {
            cache.put(i, "value" + i);
        }

        // Now perform mixed access pattern: frequently access hot data
        for (int round = 0; round < 50; round++) {
            // Access hot data repeatedly (80% of accesses)
            for (int i = 0; i < 80; i++) {
                cache.put(i % 100, "value" + (i % 100)); // Repeatedly access 0-99
            }

            // Access cold data less frequently (20% of accesses)
            for (int i = 0; i < 20; i++) {
                int coldKey = 100 + ((round * 20 + i) % 900);
                cache.put(coldKey, "value" + coldKey);
            }
        }

        // Now test get performance on hot data
        int hotHits = 0;
        int hotMisses = 0;
        for (int i = 0; i < 100; i++) {
            if (cache.get(i) != null) {
                hotHits++;
            } else {
                hotMisses++;
            }
        }

        float hotHitRate = (float) hotHits / 100;
        System.out.println("Performance benchmark (80-20 pattern):");
        System.out.println("  " + cache.toString());
        System.out.println("  Hot data hit rate: " + (hotHitRate * 100) + "% (" + hotHits + "/100)");

        // ARC should keep hot data in cache with high hit rate
        assertThat(hotHitRate).isGreaterThan(0.5f);
    }

    @Test
    @DisplayName("Adaptive parameter 동작 검증")
    void testAdaptiveParameterBehavior() {
        ARCCacheTableWithStats<Integer, String> cache = new ARCCacheTableWithStats<Integer, String>().setMaxRow(100);

        // Phase 1: Recency pattern - sequential access
        for (int i = 0; i < 200; i++) {
            cache.put(i, "value" + i);
        }

        int pAfterRecency = cache.getP();
        System.out.println("After recency pattern, p = " + pAfterRecency);

        // Phase 2: Frequency pattern - repeated access to small set
        for (int round = 0; round < 10; round++) {
            for (int i = 0; i < 50; i++) {
                cache.put(i, "value" + i + "_r" + round);
            }
        }

        int pAfterFrequency = cache.getP();
        System.out.println("After frequency pattern, p = " + pAfterFrequency);
        System.out.println("Adaptation count: " + cache.adaptationCount());

        // p should adapt based on workload
        assertThat(cache.adaptationCount()).isGreaterThan(0);
    }

    @Test
    @DisplayName("Memory efficiency - Ghost entry 대비 실제 캐시 비율")
    void testMemoryEfficiency() {
        ARCCacheTable<Integer, String> cache = new ARCCacheTable<Integer, String>().setMaxRow(100);

        // Generate heavy eviction scenario
        for (int i = 0; i < 1000; i++) {
            cache.put(i, "value" + i);
        }

        int actualCacheSize = cache.size();
        System.out.println("Memory efficiency test:");
        System.out.println("  " + cache.getStats());
        System.out.println("  Actual cache size: " + actualCacheSize);
        System.out.println("  Max size: " + cache.maxSize());

        // Actual cache should not exceed maxSize
        assertThat(actualCacheSize).isLessThanOrEqualTo(cache.maxSize());
    }
}
